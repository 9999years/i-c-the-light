<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>distance estimation</title>
	</head>
	<body>
		<canvas id="canvas"></canvas>
<script>
//distance from a line segment
//this also can be a <canvas> pixel shader boilerplate

//plot a pixel on arbitrary image data
//image = ctx.createImageData...
//color = rgba byte array
function plot(image, x, y, color) {
	var inx = (y * image.width * 4) + (x * 4);
	image.data[inx]   = color[0];
	image.data[++inx] = color[1];
	image.data[++inx] = color[2];
	image.data[++inx] = color[3];
	return;
}

//supporting functions
function sqr(x) {
	return x * x;
}

//dist between two coords
function dist2(v, w) {
	return sqr(v.x - w.x) + sqr(v.y - w.y);
}

function clamp(val, min, max) {
	return Math.min(Math.max(val, min), max);
}

function sub(a, b) {
	return {
		x: a.x - b.x,
		y: a.y - b.y
	};
}

function add(a, b) {
	return {
		x: a.x + b.x,
		y: a.y + b.y
	};
}

function dot(a, b) {
	return (a.x + b.x) * (a.y + b.y);
}

//http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
function distToSegmentSquared(p, v, w) {
	var l2 = dist2(v, w);
	if (l2 == 0) return dist2(p, v);
	var t =  ((p.x - v.x) * (w.x - v.x)
		+ (p.y - v.y) * (w.y - v.y))
		/ l2;
	t = clamp(t, 0, 1);
	return dist2(
		p,
		{
			x: v.x + t * (w.x - v.x),
			y: v.y + t * (w.y - v.y)
		});
}

function distToSegment(p, v, w) {
	return Math.sqrt(distToSegmentSquared(p, v, w));
}

//make gray color from byte
function gray(v) {
	v = clamp(v, 0, 0xff);
	return [v, v, v, 100];
}

(function() {
	//initialize cvs, ctx, etc
	var cvs = document.getElementById('canvas'),
	ctx = cvs.getContext('2d'),
	frameWidth = 500,
	frameHeight = 500,
	time = 0;

	cvs.setAttribute('height', frameHeight);
	cvs.setAttribute('width', frameWidth);

	var render = function(time) {
	//time is waaaaay too big, get it a bit smaller
	time /= 200;
	//set up the end points, make them wiggle with sin/cos
	var v = {
		x: 80  + 15 * Math.cos(time),
		y: 120 + 15 * Math.sin(time)
	};
	//offset so both coordinates aren't on the same cycle
	time += 1;
	var w = {
		x: 375 + 35 * Math.cos(time),
		y: 400 + 35 * Math.sin(time)
	};

	var p = {
		x: 0,
		y: 0
	};

	//create pixel array
	var image = ctx.createImageData(frameWidth, frameHeight);
	//iterate through the image
	for(var x = 0; x < frameWidth; x++) {
		for(var y = 0; y < frameHeight; y++) {
			p.x = x;
			p.y = y;
			//plot 100/distance as the brightness
			plot(image, x, y, gray(100/distToSegment(p, v, w)));
			}
		}
	//push array to canvas
	ctx.putImageData(image, 0, 0);
	//update time, push a frame, call render() again
	time = window.requestAnimationFrame(render);
	};
	//first call
	render.call();
}());
</script>
	</body>
</html>
